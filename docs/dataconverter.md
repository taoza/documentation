---
id: dataconverter
title: Data Converter
sidebar_label: Data Converter
description: This guide provides a comprehensive overview of Data Converter.
toc_max_heading_level: 4
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

This guide provides a comprehensive overview of Data Converter.

A Data Converter is a Temporal SDK component that encodes and decodes data entering, stored on, and exiting a Temporal Cluster.
It is used by the Temporal SDK framework to serialize/deserialize input and output of Activities and Workflows that need to be sent over the wire to the Temporal Cluster.

<div class="tdiw"><div class="tditw"><p class="tdit">Data Converter encodes and decodes data</p></div><div class="tdiiw"><img class="img_ev3q" src="/diagrams/default-data-converter.svg" alt="Data Converter encodes and decodes data" height="1240" width="2300" /></div></div>

The Data Converter encodes all data from your application before it is sent to the Temporal Cluster in the Client call. When the Temporal Server sends the encoded data back to the Worker, the Data Converter decodes the data for processing within your application. This ensures that all your sensitive data exists in its original format only on hosts that you control.

The main pieces of data that run through the Data Converter are arguments and return values:

- The Client:
  - Encodes Workflow, Signal, and Query arguments.
  - Decodes Workflow and Query return values.
- The Worker:
  - Decodes Workflow, Signal, and Query arguments.
  - Encodes Workflow and Query return values.
  - Decodes and encodes Activity arguments and return values.

Each piece of data (like a single argument or return value) is encoded as a Payload Protobuf message, which consists of binary data and key-value metadata.

## Default Data Converter

Each Temporal SDK includes and uses a default Data Converter.
The default Data Converter converts objects into bytes using a series of Payload Converters.
In most SDKs, the default converter supports binary, JSON, and Protobufs and encodes values in the following order:

- Null
- Binary
- Protobuf JSON
- JSON

In SDKs that cannot determine parameter types at runtime—like TypeScript—Protobufs aren't included in the default converter.

For example:

- If a value is an instance of a Protobuf message, it will be encoded with [proto3 JSON](https://developers.google.com/protocol-buffers/docs/proto3#json).
- If a value isn't null, binary, or a Protobuf, it will be encoded as JSON. If any part of it is not serializable as JSON (for example, a Date—see JSON data types), an error will be thrown.

The default converter also supports decoding binary Protobufs.

## Custom Data Converter

You can create a custom Data Converter to alter formats (for example using [MessagePack](https://msgpack.org/) instead of JSON) or add compression and encryption.

You can customize the default Data Converter behavior in two ways:

- To convert custom types to payloads and back, use a custom `PayloadConverter` and set it to alter the default Data Converter.
- To use custom encryption and/or compression logic, create a custom `PayloadCodec` with your encryption/compression logic in the `encode` function, and your decryption/decompression logic in your `decode` function.

Custom Data Converters are not applied to all data:

- Search Attributes are always encoded with JSON.
- Headers are not encoded by the SDK (the one exception will be—when implemented—the SDK [running OTel baggage through custom Codecs](https://github.com/temporalio/sdk-typescript/issues/514)).

### Payload Converter​

Some SDKs have a Payload Converter as a part of the Data Converter, that does the conversion from a value to a Payload and back.
See the API reference for more information.

- [Go](https://pkg.go.dev/go.temporal.io/sdk@v1.20.0/converter#PayloadConverter)
- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/common/converter/PayloadConverter.html)
- [TypeScript](https://typescript.temporal.io/api/classes/common.DefaultPayloadConverter#converters)
- [Python](https://python.temporal.io/temporalio.converter.PayloadConverter.html)

#### Custom Payload Conversion

When you request a Workflow Execution through your Client and pass a data input, the input is deserialized using the default Data Converter.
When your Workflow Execution starts, this data input is serialized and passed as input to your Workflow.

You can set multiple custom PayloadConverters to run your conversions. However, the order in which encoding payload converters are applied is important because during serialization, each encoding Payload Converter is tried in order until one properly serializes the value.

### Failure Converter​

A Failure Converter converts error objects to proto Failures and back.
The default Failure Converter copies error messages and stack traces as plain text.

- [Go](https://pkg.go.dev/go.temporal.io/sdk@v1.21.0/converter#FailureConverter)
- [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/failure/FailureConverter.html)
- [TypeScript](https://typescript.temporal.io/api/interfaces/common.FailureConverter)
- [Python](https://python.temporal.io/temporalio.converter.FailureConverter.html

You can make a custom Failure Converter, but if you use multiple SDKs, you will have to implement the same logic in each.
Custom/customizable failure converter is not yet supported in Java.

If your errors may contain sensitive information, you can encrypt the message and stack trace by configuring the default Failure Converter to use your Payload Codec, in which case it will move your `message` and `stack_trace` fields to a payload that's run through your codec.

### Payload Codec

A Payload Codec transforms an array of Payloads (for example, a list of Workflow arguments) into another array of Payloads.

The Payload Codec is an optional step that happens between the wire and the Payload Converter:

```bash
Temporal Server <--> Wire <--> Payload Codec <--> Payload Converter <--> User code
```

When serializing to Payloads:

- Data Converter is applied first, followed by the chain of codecs.
- Codecs are applied last to first meaning the earlier encoders wrap the later ones.

When deserializing from Payloads:

- Codecs are applied first to last to reverse the effect, followed by the Data Converter.
- Data Converter is applied last.

Use a Payload Codec to transform your payloads, for example by implementing compression and/or encryption and decryption.

#### Encryption​ and Decryption

Using encryption in your custom Data Converter ensures that all your sensitive application data is secure when handled by the Temporal Server. It also ensures that your data exists unencrypted only on the Client and the Worker process that is executing the Workflows and Activities, on hosts that you control.

You can implement encryption and decryption in your Payload Codec.
The following samples use encryption (AES GCM with 256-bit key) in a custom Data Converter:

- [Go sample](https://github.com/temporalio/samples-go/tree/main/encryption)
- [Java sample](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)
- [TypeScript sample](https://github.com/temporalio/samples-typescript/tree/main/encryption)
- [Python sample](https://github.com/temporalio/samples-python/tree/main/encryption)

### Remote data encoding

You can use your custom Data Converter to decode (and encode) your payloads remotely through endpoints.

Running your encoding remotely allows you to:

- Reuse complicated encryption logic written once between different languages
- Use it with `tctl` to encode payloads for `tctl workflow start` and with Temporal WebUI to [decode encrypted payloads](#decoding-payloads-on-the-webui-and-tctl)
- Create a service that has access to encryption keys for performing the encryption/decryption instead of a developer workstation or service accessing the keys directly.

To run data encoding/decoding remotely, use a Codec Server. A Codec Server is an HTTP server that is configured to use your custom Payload Codec with encryption/compression and decryption/decompression logic. See [Codec Server](/security#codec-server) for more information.

Before you use a remote data encoder to encode your payloads, ensure that you consider all the security implications of running encryptions remotely.

#### Decoding payloads on the Web UI and tctl

If you use custom encryption/encoding with your custom Data Converter, all the data handled by the Temporal Cluster is encrypted/encoded. Since the WebUI uses the <a class="tdlp" href="/visibility#">Visibility<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><span class="tdlpc"><span class="tdlppt">What is Visibility?</span><br /><br /><span class="tdlppd">The term Visibility, within the Temporal Platform, refers to the subsystems and APIs that enable an operator to view Workflow Executions that currently exist within a Cluster.</span><span class="tdlplm"><br /><br /><a class="tdlplma" href="/visibility#">Learn more</a></span></span></a> database to show events and data stored on the Temporal Server, all data in the Workflow Execution History in your WebUI or tctl is encoded/encrypted.

To see the original format of data in your WebUI and tctl, create a Codec Server with a remote data encoder and use the Payload Codec to decode your data locally.

Note that an encryption/decryption remote data encoder is a separate system with access to your encryption keys and exposes APIs to encode and decode any payloads that are encrypted with the Payload Codec used. Evaluate and ensure that your RDE endpoints are secured and only authorized users have access to them.

Samples:

- [Go](https://github.com/temporalio/samples-go/tree/main/codec-server)
- [Java](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)
- [TypeScript](https://github.com/temporalio/samples-typescript/tree/main/encryption)
- [Python](https://github.com/temporalio/samples-python/tree/main/encryption)

