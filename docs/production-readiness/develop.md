---
id: develop
title: Temporal production readiness guide - Develop
sidebar_label: Develop
description: This guide explains what you need to develop to use Temporal in your production environment.
toc_max_heading_level: 4
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

This guide explains what you need to develop to use Temporal in your production environment.

## Data Encryption

Using encryption in your custom Data Converter ensures that all your sensitive application data is secure when handled by the Temporal Server.
It also ensures that your data exists unencrypted only on the Client and the Worker process that is executing the Workflows and Activities, on hosts that you control.

Most SDKs provide a <a class="tdlp" href="/dataconversion#payload-codec">`PayloadCodec`<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><span class="tdlpc"><span class="tdlppt">What is a Payload Codec?</span><br /><br /><span class="tdlppd">A Payload Codec transforms an array of Payloads (for example, a list of Workflow arguments) into another array of Payloads.</span><span class="tdlplm"><br /><br /><a class="tdlplma" href="/dataconversion#payload-codec">Learn more</a></span></span></a> that transforms your payloads, for example by implementing compression and/or encryption and decryption.
The Payload Codec is an optional step that happens between the wire and the Payload Converter:

```bash
Temporal Server <--> Wire <--> Payload Codec <--> Payload Converter <--> User code
```

A `PayloadCodec` implementation is applied with a custom Data Converter in your Client that you use with Workers and to start Workflow Executions.

You can run your `PayloadCodec` <a class="tdlp" href="/dataconversion#remote-data-encoding">remotely<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><span class="tdlpc"><span class="tdlppt">What is remote data encoding?</span><br /><br /><span class="tdlppd">Remote data encding is using your custom Data Converter to decode (and encode) your payloads remotely through endpoints.</span><span class="tdlplm"><br /><br /><a class="tdlplma" href="/dataconversion#remote-data-encoding">Learn more</a></span></span></a> with a <a class="tdlp" href="/security#codec-server">Codec Server<span class="tdlpiw"><img src="/img/link-preview-icon.svg" alt="Link preview icon" /></span><span class="tdlpc"><span class="tdlppt">What is a Codec Server?</span><br /><br /><span class="tdlppd">A Codec Server is an HTTP server that runs data from tctl or the Web UI through a Payload Codec.</span><span class="tdlplm"><br /><br /><a class="tdlplma" href="/security#codec-server">Learn more</a></span></span></a>, and use the Codec Server endpoints in your WebUI and tctl to decode your encrypted paylods locally.

However, if you plan on setting up remote data encoding for all your payloads, ensure that you consider all security implications of running encryptions remotely before implementing it.

In codec implementations, we recommend running the function (whether it be compressing, encrypting, etc) on the entire input Payload, and putting the result in a new Payload's data field. That way, the input Payload's headers are preserved.

Examples for implementing compression:

- [ZlibCodec in Go](https://github.com/temporalio/sdk-go/blob/706516c7077ba2e9b40304aeddbed47e25b2a68f/converter/codec.go#L77-L105)
- [Encryption Data Converter](https://github.com/temporalio/samples-go/blob/15be864c80d4d983ebb8a8fbd3fa5263bcef6930/encryption/data_converter.go#L100-L126) in Go's encryption sample.

<Tabs
defaultValue="go"
queryString="lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

**Create a custom Payload Codec**

Create a custom [`PayloadCodec`](https://pkg.go.dev/go.temporal.io/sdk@v1.20.0/converter#PayloadCodec) implementation and define your encryption/compression and decryption/decompression logic in the `encode` and `decode` functions.

The `PayloadCodec` converts bytes to bytes. It must be used in an instance of a `CodecDataConverter` that wraps a Data Converter to do the payload conversions, and applies the custom encoding and decoding in the `PayloadCodec` to the converted payloads.

The following example shows how to create a custom `NewCodecDataConverter` that wraps an instance of a Data Converter with a custom `PayloadCodec`.

```go
// Create a new instance of Data Converter
var DataConverter = NewDataConverter(converter.GetDefaultDataConverter())

// NewDataConverter creates a new data converter that wraps the given data
// converter with snappy compression, using the custom PayloadCodec called NewPayloadCodec.
func NewDataConverter(underlying converter.DataConverter) converter.DataConverter {
	return converter.NewCodecDataConverter(underlying, NewPayloadCodec())
}

// Create a new instance of PaylodCodec
func NewPayloadCodec() converter.PayloadCodec {
	return &Codec{}
}
```

Implement your encryption and compression logic in the `encode` function, and the decryption and decompression logic in the `decode` function in your custom `PayloadCodec`, as shown in the following example.

```go
// Codec implements converter.PayloadEncoder for snappy compression.
type Codec struct{}

// Encode implements converter.PayloadCodec.Encode.
func (e *Codec) Encode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {
	//your encryption/compression logic
	return result, nil
}

// Decode implements converter.PayloadCodec.Decode.
func (*Codec) Decode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {
	//your decryption/decompression logic
	return result, nil
}
```

You can also create a remote HTTP server (called Codec Server) to run the encryption and decryption through the custom `PayloadCodec`, and expose endpoints that you can use with WebUI and tctl to see decrypted data.

**Set Data Converter to use custom Payload Codec**

Set your custom `PaylaodCodec` with an instance of `DataConverter` in your `Dial` client options that you use to create the client for your Worker process and to start Workflow Executions.

The following example shows how to set a custom `PayloadCodec` implementation called `codecserver` in the client options.

```go
//...
c, err := client.Dial(client.Options{
		// Set DataConverter here to ensure that workflow inputs and results are
		// encoded as required.
		DataConverter: codecserver.DataConverter,
	})
//...
```

You can also create a remote HTTP server (called Codec Server) to run encryption and decryption through the custom `PayloadCodec`, and expose endpoints that you can use with WebUI and tctl to see decrypted data.
If running your custom `PayloadCodec` through a remote data encoder, set the the custom `PayloadCodec` per Namespace, as shown in the following example:

```go
// Set codecs per namespace here.
// Only handle codecs for the default namespace in this example.
codecs := map[string][]converter.PayloadCodec{
	"default": {codecserver.NewPayloadCodec()},
}
```

See the following samples for examples:

- [codec-server](https://github.com/temporalio/samples-go/tree/af2614a728e3dd9640f3a3e95873f96a4e56f81a/codec-server)
- [encryption](https://github.com/temporalio/samples-go/tree/af2614a728e3dd9640f3a3e95873f96a4e56f81a/encryption)

</TabItem>
<TabItem value="java">

**Create a custom Payload Codec**

Create a custom implementation of the [`PayloadCodec`](https://www.javadoc.io/static/io.temporal/temporal-sdk/1.18.1/io/temporal/payload/codec/PayloadCodec.html) and use it in a `CodecDataConverter` to set a custom Data Converter.

The Paylod Codec does byte to byte conversion, and must be set with a Data Converter to do the conversion to bytes and values.

Define custom encryption/compression logic in your `encode` method, and decryption/decompression logic in your `decode` method.

```java
public class YourCustomPayloadCodec implements PayloadCodec {
     @NotNull
    @Override
    public List<Payload> encode(@NotNull List<Payload> payloads) {
        //your encryption/compression logic
    }

    @NotNull
    @Override
    public List<Payload> decode(@NotNull List<Payload> payloads) {
        //your decryption/decompression logic
    }
```

You can also create a remote HTTP server (called Codec Server) to run the encryption and decryption through the custom `PayloadCodec`, and expose endpoints that you can use with WebUI and tctl to see decrypted data.

**Set Data Converter to use custom Payload Codec**

Use `CodecDataConverter` with an instance of a Data Converter and the custom `PayloadCodec` in the `WorkflowClient` options that you use in your Worker process and to start your Workflow Executions.

For example, to set a custom `PayloadCodec` implementation with the `DefaultDataConverter`, use:

```java
WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();
  // client that can be used to start and signal workflows
  WorkflowClient client =
      WorkflowClient.newInstance(
          service,
          WorkflowClientOptions.newBuilder()
              .setDataConverter(
                  new CodecDataConverter(
                      DefaultDataConverter.newDefaultInstance(),
                      Collections.singletonList(new YourCustomPayloadCodec())))
              .build());
```

See the following samples for example implementations:

- [Encrypted Payloads](https://github.com/temporalio/samples-java/tree/main/src/main/java/io/temporal/samples/encryptedpayloads)
- [Remote Data Encoder and Codec Server](https://github.com/temporalio/sdk-java/tree/master/temporal-remote-data-encoder)

</TabItem>
<TabItem value="php">

Content is planned but not yet available.

The information you are looking for may be found in the [legacy docs](https://legacy-documentation-sdks.temporal.io/).

</TabItem>
<TabItem value="python">

Content is planned but not yet available.

The information you are looking for may be found in the [legacy docs](https://legacy-documentation-sdks.temporal.io/).

</TabItem>
<TabItem value="typescript">

Content is planned but not yet available.

The information you are looking for may be found in the [legacy docs](https://legacy-documentation-sdks.temporal.io/).

</TabItem>
</Tabs>

